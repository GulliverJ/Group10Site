<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Group 10</title>
    <!-- Bootstrap -->
    <link href="http://getbootstrap.com/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="css/styles.css" rel="stylesheet">
    <link rel="icon" type="type/png" href="img/favicon_3.png"/>
  </head>
  <body data-spy="scroll" data-target=".scrollspy">

    <!-- Top navbar -->
    <div class="navbar navbar-fixed-top">
      <div class="wrapper">

        <div class="logo">
          <a href="index.html"><img src="img/title.png"></a>
        </div>
        <div class="nav" id="topnav">
          <ul>
            <li style="display: inline"><a href="" class="nav-list onpage">Showcase</a></li>
            <li style="display: inline"><a href="demo.html" class="nav-list">Demo</a></li>
            <li style="display: inline"><a href="collab.html" class="nav-list">Collaborate</a></li>
            <li style="display: inline"><a href="docs.html" class="nav-list">Documentation</a></li>
            <li style="display: inline"><a href="dev.html" class="nav-list">Development</a></li>
            <li style="display: inline"><a href="http://orangesensorsapis.freeforums.net/" class="nav-list">Forum</a></li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Dark grey page header -->
    <div class="pageheader">
      <div class="container">
        <div class="embed-responsive embed-responsive-16by9 video">
          <iframe class="embed-responsive-item" src="https://www.youtube.com/embed/I_Dkeb1bAdI?rel=0&showinfo=0&controls=0" frameborder="0"></iframe>
        </div>
        <div>
          <h1 style="color: #f60">Project Showcase</h1>
          <p class="pageblurb">This page showcases the ins and outs of our design as a progression from requirements and specification to construction and testing.</p>
          <p class="pageblurb">Take a look at our video as we demonstrate the full system in use, from building hardware to watching the results shown in real-time. The footage was filmed entirely using software already running <a href="http://victokoh.cs.ucl.ac.uk">here</a>. Feel free to sign up, download the sample sensor code, and experiment for yourself!</p><br>
        </div>
      </div>
    </div>

    <div class="content-body">
      <div class="container">
        <div class="row">

          <!-- Side nav -->
          <div class="col-md-3 nopadding scrollspy" id="leftcol">
            <div class="affix-top" id="sidebar" data-spy="affix">
                <ul class="nav hidden-xs hidden-sm">
                  <li style="background-color: #1b1b1b; padding-top: 10px; border-top-left-radius: 10px; border-top-right-radius: 10px; border: 1px #eee solid"><span style="padding: 16px; color: #fff">Navigation</span><p></li>
                  <li><a href="#req">Requirements</a></li>
                  <li><a href="#spec">Specification and Design</a></li>
                  <li><a href="#imp">Implementation</a></li>
                  <li><a href="#ach">Technical Achievements</a></li>
                  <li><a href="#test">Testing</a></li>
                  <li><a href="#eval">Evaluation</a></li>
                </ul>
            </div>
          </div>

          <!-- MAIN CONTENT -->
          <div class="col-md-9 nopadding main-content">

            <!-- Requirements -->
            <h2 style="margin-top: 12px">Requirements and Goals</h2>
            <a class="anchor" id="req"></a>
            <hr>
            <h3>A Brief Introduction</h3>
			<p> 
				For our final proof of concept in term two, identifying the key, finalised requirements involved a series of steps. 
				Just before the start of the second term, the team gathered in order to pool together ideas and research carried out in term one.
				From this, we produced two documents which were subsequently sent to our client(s) at Orange Labs. A meeting at their office to go over these
				and our prototype from term one involving the use of Bluetooth to connect sensor hardware to computer, a MySQL Azure database and Analytics in 
				JAVA was then scheduled for 20th January. 
			</p>
			<p>
				The two aforementioned draft documents can be downloaded below:
				<ul>
				<li><a href="https://www.dropbox.com/s/o4dgxoqszy7m2ke/proposal_draft.pdf?dl=1">Project Proposal</a></li>
				<li><a href="https://www.dropbox.com/s/7cs0uoqsto5y3me/proposed_deliverables.pdf?dl=1">Timeline of Deliverables</a></li>
				</ul>
				<p>
				From these two documents and the feedback received from our client(s) during the meeting on 20th January which can be downloaded <a href="https://www.dropbox.com/s/0ykehuqdz6bmok5/%2820thJAN%29MEETING%20WITH%20CLIENT%20IIII.docx?dl=1">here</a>, 
				final requirements and project goals were derived. 
				</p>
				
				<h4>General requirements and goals we aim to meet for this project include: </h4>
				<p><em>Note: A more detailed list can be found under Specification below.</p></em>
				
				
            <table>
              <tr class="head">
                <th style="width: 10%">ID</th>
                <th style="width: 90%">Requirement</th>
              </tr>
              <tr><td>1</td><td>The system must have a plug & play architecture in order to enable swift and flexible adding of new sensor hardware to the network</td></tr>
              <tr><td>2</td><td>The system must have a scalable infrastructure given the vast and growing amount of data it will be required to support long-term</td></tr>
			  <tr><td>3</td><td>The system, through its platform, must enable the meshing of sensor data and support a variety of different types of sensor data</td></tr>
              <tr><td>4</td><td>There must be a set of APIs through which the database(s) can be accessed</td></tr>
			  <tr><td>5</td><td>Sensor data from the system should be made publicly available and be easy-to-aggregate together</td></tr>
              <tr><td>6</td><td>All sensor data should also be presented in a uniform, standardised and clear format</td></tr>
			  <tr><td>7</td><td>There must be two different Web-based applications 'GUIs', the first being a sensor management portal and
				the second being an smart parking app </td></tr>
              <tr><td>8</td><td>Basic analytics must be carried out for the smart parking application</td></tr>
			  <tr><td>9</td><td>Accuracy of hardware in vehicle detection should be prioritised over low costs</td></tr>
              <tr><td>10</td><td>The hardware must include a central module "zone controller" and sensor unit(s)</td></tr>
			  <tr><td>11</td><td>The system must have a degree of authentication present in order to prevent abuse </td></tr>
            </table>
	
            <!-- Sepcification and Design -->
            <h2>Specification and Design</h2>
            <a class="anchor" id="spec"></a>
            <hr>
            <h3>Functional Specification</h3>
            <p>Provided below is a more in-depth look into the scope of our project divided by category:</p>
			
			
			
			
			 <table>
              <tr class="head">
                <th style="width: 10%">ID</th>
				<th style="width: 25%">Category</th>
                <th style="width: 65%">Requirement</th>
              </tr>
              <tr><td>1</td><td> System Website </td><td> Users should be able to indicate sensor position on an interactive Google map</td></tr>
			  <tr><td>2</td><td> System Website </td><td> Users must be able to add new sensors to the network via this platform easily</td></tr>
			  <tr><td>3</td><td> System Website </td><td> The adding of new sensors should be a swift and easy-to-complete process</td></tr>
			  <tr><td>4</td><td> System Website </td><td> Some degree of authentication must be required for security purposes when adding new sensor hardware to the network</td></tr>
			  <tr><td>5</td><td> System Website </td><td> The platform should be responsive designed, owing to users on the move in the environment to set up sensors</td></tr>
			  <tr><td>6</td><td> System Website </td><td> The platform should notify users when their sensors have potentially broken down i.e. via the lack of an update over a set interval of time</td></tr>
			  <tr><td>7</td><td> System Website </td><td> The platform should be easy to navigate, there must be clarity in content present</td></tr>
			  <tr><td>8</td><td> System Website </td><td> Users should be able to easily manage their own set of sensors on the portal page</td></tr>
			  <tr><td>9</td><td> System Website </td><td> The design of the websites' pages must not affect its overall usability negatively</td></tr>
			  <tr><td>10</td><td> System Website </td><td> Users must be able to sign up to the platform</td></tr>
			  <tr><td>11</td><td> Usecase Hardware </td><td> Must be able to transmit data wirelessly via UDP.</td></tr>
			  <tr><td>12</td><td> Usecase Hardware </td><td> For the use case of illegal parking, must be able to accurately tell if a bay is occupied or not</td></tr>
			  <tr><td>13</td><td> Usecase Hardware </td><td> While accuracy should be prioritised, hardware should ideally be low-powered</td></tr>
			  <tr><td>14</td><td> Usecase Hardware </td><td> Hardware should be low fixed cost and low maintenance cost</td></tr>
			  <tr><td>15</td><td> Usecase Hardware </td><td> Code should allow for easy modification of sensor identifier.</td></tr>
			  <tr><td>16</td><td> Usecase Hardware </td><td> Hardware should allow for easy reconfiguration as sensors are moved around.</td></tr>
			  <tr><td>17</td><td> Usecase Hardware </td><td> Hardware should be robust so that physical maintenance is kept at a minimum.</td></tr>
			  <tr><td>18</td><td> Parking Application </td><td>Must have a graphical overlay in order to communicate information like bay occupancy visually to users</td></tr>
			  <tr><td>19</td><td> Parking Application </td><td> Should be able to tell whether a bay has been illegally occupied</td></tr>
			  <tr><td>20</td><td> Parking Application </td><td> Should include additional parking data for instance time restrictions placed upon bays</td></tr>
			  <tr><td>21</td><td> Parking Application </td><td> Should automatically update a bay's occupancy along with its associated information</td></tr>
			  <tr><td>22</td><td> Parking Application </td><td> All and any features should be easily noticeable</td></tr>
			  <tr><td>23</td><td> Analytics </td><td> Basic analytics must calculate bay occupancy</td></tr>
			  <tr><td>24</td><td> Analytics </td><td> Whether a bay is legally or illegally occupied must also be calculated</td></tr>
			  
			  
		   </table>
         
            <div class="subsection-divide"></div>
            <h3>High-level System Design</h3>
            <p>As an overview, this graphic illustrates the high-level interpretation of our system design. The sensors in the environment will send their data as UDP packets to the main server. The main server has a web front-end, and handles processing and storing the data. Two APIs can then be used to access the data, allowing developers to apply it to external applications.</p>
            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/overview.png">
              <p>A high-level overview of the system design as a whole.</p>
            </div>

            <!-- Implementation -->
            <h2>Implementation</h2>
            <a class="anchor" id="imp"></a>
            <hr>

            <h3>Implementing the System</h3>
            <p>The 'system' comprises everything to do with receiving and storing data from sensors on the network. Through the system, users can register sensors by giving information like their exact coordinates and what they measure. On a website end, they can manage their sensors and download the APIs. In the background, we have Java software running, listening to a specific port and waiting to receive packets. Each packet is validated, then inserted into the main readings database, ready to be accessed via one of our APIs.</p>
            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/system_overview.png">
              <p>An overview of the inner workings of the system.</p>
            </div>

            <p>The source code for the system is, of course, included in our <a href="https://github.com/GulliverJ/comp2014">GitHub repository</a>, under the folder 'orange-sensors-system'.</p>

            <div class="subsection-divide"></div>

            <h4>Data Storage</h4>
            <p>As seen in the above overview, the system contains two distinct databases; an SQL databse containing sensitive data relating to the users, and a NoSQL database running on <a href="http://cassandra.apache.org/">Apache Cassandra</a> for storing all public sensor data. The tables and their basic relationships can be seen here, along with the access permissions according to the legend below.</p>
            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/database_system_highlevel.png">
              <p>An overview of the databases and tables used in the system backend.</p>
            </div>
            <p>Let's first have a look at the SQL database, designed for storing sensitive data about users, along with metadata about all sensors. We've chosen MySQL to implement this table, due to it being widely supported and documented, as well as convenient to use in conjunction with a web-based front-end. Its schema can be found <a href="res/orangesystem.sql">here</a>.</p>

            <p style="font-weight: bolder">Operators table</p>
            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/system_table_operators.png">
              <p>The column description for the operators table.</p>
            </div>
            <table>
              <tr class="head">
                <th style="width: 20%">Column Name</th>
                <th style="width: 70%">Description</th>
              </tr>
              <tr>
                <td>operator_id</td>
                <td>An auto-incrementing integer acting as a unique ID for each user. Only the system will see this.</td>
              </tr>
              <tr>
                <td>company</td>
                <td>Essentially a username, though we recommend users to enter their company name as their username, and share a corporate account. No user will be able to see any other usernames on the system; these are private.</td>
              </tr>
              <tr>
                <td>password</td>
                <td>The user's password, to be encrypted.</td>
              </tr>
              <tr>
                <td>contact_name</td>
                <td>The name that will be used in any correspondence with this user.</td>
              </tr>
              <tr>
                <td>contact_address</td>
                <td>The email address to which correspondence will be sent</td>
              </tr>
              <tr>
                <td>joined</td>
                <td>The date the user joined the system (auto-generated)</td>
              </tr>
            </table>

            <p style="font-weight: bolder">Sensors table</p>
            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/system_table_sensors.png">
              <p>The column description for the operators table.</p>
            </div>
            <table>
              <tr class="head">
                <th style="width: 20%">Column Name</th>
                <th style="width: 70%">Description</th>
              </tr>
              <tr>
                <td>global_id</td>
                <td>The unique, system-wide integer ID for the sensor</td>
              </tr>
              <tr>
                <td>operator_id</td>
                <td>The ID of the operator who set this sensor up.</td>
              </tr>
              <tr>
                <td>sensor_id</td>
                <td>The ID of the sensor relative to the order of creation for this user - every user's first sensor will have a sensor_id of 1, for instance, but their global IDs are entirely unrelated. This is for the convenience of the users, allowing them to more coherently manage their sensors and initialise their data strings.</td>
              </tr>
              <tr>
                <td>application</td>
                <td>An optional label for the sensor. Users can query by this label to find their data more quickly.</td>
              </tr>
              <tr>
                <td>measures</td>
                <td>The physical property that the sensor measures, for instance Distance or Temperature</td>
              </tr>
              <tr>
                <td>unit</td>
                <td>The standard unit that this sensor's readings are sent in</td>
              </tr>
              <tr>
                <td>lat</td>
                <td>The sensor's latitude, as a 6-decimal-point float</td>
              </tr>
              <tr>
                <td>lng</td>
                <td>The sensor's longitude, as a 6-decimal-point float</td>
              </tr>
            </table>

            <p style="font-weight: bolder">Identifiers table</p>
            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/system_table_identifiers.png">
              <p>The column description for the operators table.</p>
            </div>
            <table>
              <tr class="head">
                <th style="width: 20%">Column Name</th>
                <th style="width: 70%">Description</th>
              </tr>
              <tr>
                <td>operator_id</td>
                <td>The operator ID of a user. This is a foreign key referencing the Operators table.</td>
              </tr>
              <tr>
                <td>identifier</td>
                <td>A unique, 8-character, randomly generated alpha-numerical identifier, for e.g. a4bsc9swm. This is generated in PHP at time of user registration, and is used for anonymous identification of incoming data. Users must prepend their sensor's data string with this identifier, where the system software (see a later section) will check it to ensure it matches for a valid user, and from this find its global_id.</td>
              </tr>
            </table>
            <p>Again, the schema for this database can be downloaded <a href="res/orangesystem.sql">here</a>.</p>
            <p>The Cassandra database we've used has a slightly more complex structure, owing to its NoSQL concepts. Cassandra is well-documented, in terms of its data model and installation, so we won't labour the basics here. In fact, Cassandra was chosen partly due to its relatively wide level of documentation, along with its support for additional software like Hadoop and Druid, to be used for later analytics. Cassandra also provides flexible scalability, greatly simplifying the process of server expansion by automated data sharing across server nodes.</p>
            <p>Here's a closer look at the columnfamily designs. Note that the sensor_details columnfamily shares many columns with the Sensors table in the SQL database - for this reason, shared columns will be omitted.</p>

            <p style="font-weight: bolder">Sensor_details table</p>
            <table>
              <tr class="head">
                <th style="width: 20%">Column Name</th>
                <th style="width: 70%">Description</th>
              </tr>
              <tr>
                <td>first_added</td>
                <td>The date and time that the sensor was first initialised.</td>
              </tr>
              <tr>
                <td>reading</td>
                <td>The most recently received reading for this sensor, as a float value. Initialised null.</td>
              </tr>
              <tr>
                <td>timestamp</td>
                <td>The timestamp for the most recently received reading.</td>
              </tr>
            </table>

            <p style="font-weight: bolder">Data_archive table</p>
            <table>
              <tr class="head">
                <th style="width: 20%">Column Name</th>
                <th style="width: 70%">Description</th>
              </tr>
              <tr>
                <td>global_id</td>
                <td>The sensor's global_id acts as a partition key in the data archive.</td>
              </tr>
              <tr>
                <td>timestamp</td>
                <td>Each reading is stored with its timestamp (the time it was received) as a cluster key. This allows users to later query the archive by giving it a specific time range, for example retrieving distinct 24 hour periods and analysing them as blocks.</td>
              </tr>
              <tr>
                <td>reading</td>
                <td>The reading from this sensor that was received at the specified timestamp, stored as a float.</td>
              </tr>
            </table>

            <p>The schema for this database can be found <a href="res/cql_schema.txt">here</a>.</p>

            <p>With these databases implemented, we can now develop the server-side software which handles data input.</p>

            <div class="subsection-divide"></div>

            <h4>Server Software</h4>
            <p>The software has a few things it needs to take care of. Specifically:</p>
            <ul class="bodylist">
              <li>Listening to a UDP port for Datagram packet receipt</li>
              <li>Processing the packets to ensure they contain valid data</li>
              <li>Checking how to organise the data and inserting it correctly</li>
            </ul>
            <p>We've written the server-side software in Java, in order to make use of its concurrency support and access to connectivity libraries for easy networking. In our software we've implemented a dedicated thread to handle each one of the three points given above; a single <span style="font-weight: bolder">Receive thread</span> will listen and wait for input, and store the packets in a DataManager object, using concurrency implementations to ensure a safe transfer of data. Once there is data held within the manager, a <span style="font-weight: bolder">Handle thread</span> will be notified, and will take from the list using a first-in, first-out approach. The Handler thread takes care of checking the identifier sent at the beginning of the string against the Users database, to ensure it matches a valid user. If a user exists for the given identifier, an <span style="font-weight: bolder">Input thread</span> will be created to insert the readings contained within that packet. This involves first using the identifier to look up the global sensor ID for each reading. The 'sensor_details' table will then be updated with the latest reading, and the 'data_archive' table will receive a new row for the data.</p>
            <p>Here's a more descriptive sequence diagram of the software approach.</p>

            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/sequence_diagram.png">
              <p>A sequence diagram for the system software, showing the relationships between threads.</p>
            </div>

            <p>These threads make use of both a DataManager class, for concurrent data transfer between the ReceiveThread and HandleThread, and a CassandraCon class, designed as an interface to the CQL database, described by these class diagrams:</p>

            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/uml_kindof.png">
              <p>A UML diagram detailing the structure of the objects involved in the system and how they're shared.</p>
            </div>

            <p>Secondary to the data handler, we must also consider that new sensors being registered through the website need to be initialised in the Cassandra database. We handle this in the server software too, through a separate system. To do this, we rely on communication between the PHP of the website and the Java code, opening a ServerSocket on a dedicated port. Whenever the PHP running the website receives a new sensor registration, it will notify the waiting Initialisation Manager, which will perform a basic 'INSERT' query using the metadata handed over by the PHP code. It will also initialise the "first_added" bay with the current timestamp.</p>
            <p>Rather than complicating the design of this class with a UML diagram, we provide the code directly. Notice that this class makes use of the CassandraCon class, allowing a simplified interface to the <a href="https://github.com/datastax/java-driver">Cassandra Java driver</a> provided by DataStax.</p>

            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/initialisationmanager.png">
              <p>The Initialisation Manager listens for a PHP connection and creates new rows in the Cassandra sensor_details table.</p>
            </div>

            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/php_initialisation.png">
              <p>The accompanying PHP code, seen in 'sensor_manager.php', which sends each element of data for a sensor on a new line..</p>
            </div>

            <p>Finally, for convenience, we can initialise all required threads through a main class as follows:</p>

            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/runner.png">
              <p>The main class for initialising the server system software.</p>
            </div>

            <div class="subsection-divide"></div>

            <h4>The Front-end</h4>
            <p>The system requirements, as specified by our clients, did not include a front-end interface; in a way, this part of the project is exceeding the scope. However, we identified a particular need for such a service as integral to the demonstration of the capabilities of the system. The website for the system is designed solely for the users, and has the following baseline requirements:</p>
            <ul class="bodylist">
              <li>Users must be able to sign up securely</li>
              <li>Users must be able to register new sensors quickly and easily</li>
              <li>Users should be provided with a way to manage their sensors</li>
              <li>Users should have easy access to information and download links for the APIs</li>
              <li>Users should be able to browse public data with a search function</li>
            </ul>

            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/frontpage.jpg">
              <p>The main page for the System website.</p>
            </div>

            <p>The resulting website is currently live, and can be viewed <a href="http://victokoh.cs.ucl.ac.uk/sensors/">here</a>, with the source code available on <a href="https://github.com/GulliverJ/sensors"> GitHub</a>. The user-friendly interface offers easy navigation between all pages, with a responsive design built using Bootstrap libraries for mobile convenience. The website's backend is almost entirely run from the Users SQL database, detailed above, with a PHP backend. Our PHP code handles user registration, log-in sessions, sensor initialisation, and a basic search function. However, we have also made use of our RESTful API in order to retrieve real-time data from the Cassandra tables and display it on the Management portal.</p>

            <p>Signing up requires just four fields - a username, contact name, password, and email address - and immediately takes users to the Management Portal</p>

            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/management_portal.jpg">
              <p>The management portal; the main page from which users can manage the sensors they own on the network.</p>
            </div>
            <p>There are three main features of the management portal:</p>
            <ul>
              <li>The 'My Sensors' table, displaying information about sensors this user owns on the network
                <ul>
                  <li>This table will display basic metadata for sensor identification, along with the latest reading and timestamp, as read from the Cassandra database. The timestamp will be coloured red in the event that it is over 24 hours old, as an alert of inactivity. Data retrieval from the Cassandra database is handled through JavaScript (specifically the getJSON method from the JQuery library), making use of our RESTful API. We're also running an AJAX system, to ensure the data is auto-updated in realtime.</li>
                </ul></li>
              <li>The 'Unique Identifier'
                <ul>
                  <li>This is the unique, randomly generated alpha-numerical code that users must send at the beginning of any data strings sent by their sensors to our system. We use this code to ensure that the data we receive is in fact intended for us, and also to gather further data on how to store it. The code is generated through a basic PHP function found in 'signup.php'.</li>
                </ul>
              </li>
              <li>The 'Register New Sensors' button
                <ul>
                  <li>This button simply takes the user to a form where they can initialise a sensor's metadata. The form is shown below, and comprises of an optional application label, a limited list of what the sensor measures (e.g. temperature, distance, acceleration...), the standard unit the measurement is recorded in (e.g. kelvin, metres, metres per second squared...) and its precise location. Using the Google Maps Javascript API, we have added a drag-and-drop marker to greatly simplify the process of indicating a sensor's location, as the coordinates must have 6 decimal points of accuracy.</li>
                </ul>
              </il>
            </ul>
            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/addsensors.png">
              <p>The form for registering new sensors. The application label "Orange Parking" was used for our <a href="demo.html">demonstration application</a></p>
            </div>

            <p>Overall, the website fully meets our self-identified requirements, though there are many improvements to be made in future, as detailed in the <a href="collab.html#goals">'Future Goals'</a> section. As with all other aspects of this design, the source files can be found in our GitHub repo.</p>

            <div class="subsection-divide"></div>

            <h4>The Java API</h4>
            <p>The APIs are critical to the requirements of the system. Easy public access to the data held within the database is indeed the keystone for the entire project, and the specific issue that our clients are looking to solve.</p>
            <p>We produced a Java API to allow for resource-intensive analytics or processes on a medium-scale. With a library of almost 30 methods, we offer both public and authenticated access to data, meaning that unregistered developers can access data to use in their projects, and registered users can enjoy the additional features such as limiting their queries to only sensors they own.</p>
            <p>The key design points are as follows</p>
            <ul class="bodylist">
              <li>Methods to retrieve a list of global_ids belonging to sensors as filtered by:
                <ul>
                  <li>Application label</li>
                  <li>Measure type</li>
                  <li>Unit</li>
                  <li>Timestamp, as a defined date range</li>
                </ul>
              </li>
              <li>Methods taking a list of global_ids as a parameter and returning a matching list of each sensor's latest reading</li>
              <li>Methods taking a single global_id as a parameter and returning any element of metadata, such as its unit</li>
              <li>Methods taking a single global_id as a parameter and returning any amount of archive data, as specified by a timestamp range</li>
            </ul>
            <p>A guide for best practice when using the Java API, along with full and detailed documentation, can be found on the <a href="docs.html">documentation page</a>.</p>

            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/example_java_code.png">
              <p>With only 3 lines (6 - 8) the Java API can be used to retrieve a filtered list of sensor IDs and their latest readings for any number of sensors.</p>
            </div>

            <p>The above code demonstrates how simple the Java API is to use, taking only a few lines to retrieve a filtered list of sensor IDs and their matching latest readings. These are only two methods from a library of over 20, using the public class alone.</p>

            <div class="subsection-divide"></div>

            <h4>RESTful API</h4>
			<p>A REST API was also produced as one of the primary requirements of the system. This was done in order to provide easy and wider public access to sensor data held
			within the Cassandra database via the well known HTTP protocol. To note, many languages also include JSON libraries for encoding, decoding and manipulating
			such data. </p>

			<p>As a purely 'public' approach to the REST API has been taken - developers do not have to be registered to .get this data. Information on sensors can be retrieved
			in terms of their global id relative to the system. </p>

			<p> Key design points to note: </p>
			
			<p>Originally, multiple methods were brainstormed for inclusion within this API. To keep it straight forward to use, this was cut down to 8 key methods.</p>
			<p>These methods include:
			<ul class="bodylist"> 
				<li>../all endpoints - to retrieve an entire list of json objects of either the most recent sensor readings or the entire backlog for each individual sensor stored 	in the archive
				</li><li>~/find/.. endpoints - to retrieve json objects filtered by one of the following:</li>
					<ul>
					<li>Individual sensor global id</li>
					<li>Range of sensor global ids</li>
					<li>Application type</li>
					<li>Measurement type</li>
					</ul>
				<li>../from endpoints - to retrieve json objects filtered by timestamp from the archive</li>

			<li>For the purposes of our system prototype, this API has been hosted on Heroku.</li>
			</ul>
			
			<p>Further information on usage of this REST API can be found on the <a href="docs.html">documentation page</a>.</p>
			<p>A general example on usage to retrieve JSON objects can be seen below, making use of the Postman REST client for clarity purposes.</p>

			<div class="imgborder">
              <img class="img-responsive img-rounded" src="img/postmanJSONtest.png">
              <p>Data retrieved by making a simple .get call</p>
            </div>

			 <div class="subsection-divide"></div>			
			
            <h3>Implementing Hardware</h3>
            <p>Whilst specific pieces of sensor hardware are certainly likely to be different - by reading different types of data and being designed to be used in different ways - there are some key elements to our system design that must be obeyed in order to work with the system. We developed sensor hardware as parking bay monitors, to be used in conjunction with our <a href="demo.html">Smart-Parking application</a>, and have detailed the important design aspects here. Anyone wishing to build hardware to use with this system must follow the same basic principles in order to ensure compatability.</p>
			<h4>Sending your data</h4>
            <p>To send your data, for now you must send it as a UDP string. It is recommended that you use anywhere from 1-10 sensors per zone controller. This means you have 1 device handling global upload of 10 devices. Using only 1 is of course less efficient to using 10, but using more than that will slow down the rate at which data will be send, as there is a small delay between each device. Technically there is no restriction as to how many you can connect, but add more at your own risk.</p>
            <p>Here is the format you must follow for your UDP strings:</p>
            <pre>identifier;sensorID:sensorReading;</pre>
            <h4>Specific Hardware </h4>
            <p>When it comes to selecting the hardware for your system, your possible choices are very broad. The only real restriction is the kind of data you are reading. For the parking application, you must send your data as a distance. This means if you are determining the state of your parking bay using a binary case or other more complicated methods, then the system will not work. You are free to use other distance measurers than infra-red, just be advised that measuring with ultrasound can be unreliably against rough surfaces.</p>
            <p>As long as you are able to send data via UDP, you can use any microcontroller/sensor combination of your liking. The tutorials we provide and recommend require you to use very specific Hardware however.</p>

            <!-- Technical Achievements -->
            <h2>Technical Achievements</h2>
            <a class="anchor" id="ach"></a>
            <hr>
            <h4 style="font-weight: lighter">In developing this system, we've broken ground on a lot of significant technical developments. Through our open system, developers can take control over the environments they live in with new-found power and intelligence, truly transforming the digital urban landscape.</h4>
            <h4>A fully flexible, crowd-sourced sensor network</h4>
            <p>The sensor network we've developed is unlike any other, offering unlimited growth and wide hardware support. We've strived to design a simplified system making it easy for developers with any level of experience to get their hardware up and running, sharing data with the world in a matter of minutes. Data aggregation on this scale has never been done before.</p>
            <h4>Scalability first</h4>
            <p>With our network design, the system accesses potentially unlimited reach. Wherever there is an internet connection, there can be sensors. Apache Cassandra allows us to easily expand the server network, with unparalleled reliability and convenience.</p>
            <h4>Standardised environmental data</h4>
            <p>Though a complex, rich bank of environmental data is often provided by governments worldwide, it is typically sequestered away or split amongst multiple providers. Our system standardises the process, delivering data in a the same format from the same location, greatly simplifying the process of writing analytics as a developer.</p>
            <h4>Truly public access, anywhere, any time</h4>
            <p>The two APIs we've provided with this proof-of-concept are just the beginning. The datasets we're storing are remarkably large, and will offer innovative aspects of big data research through analytics - never before have developers been able to explore how daily pollution levels can unexpectedly affect traffic flow across a city in so few lines of code.</p>
            <h4>Encouraging humanitarian attitudes</h4>
            <p>A more sociological development, the ease with which private companies can now contribute to the positive improvement of our urban environments simply by using our system to store their data publicly could certainly inspire a greater acceptance by the wider community.</p>

            <!-- Testing -->
            <h2>Testing</h2>
            <a class="anchor" id="test"></a>
            <hr>
            <h4 style="font-weight: lighter">Testing is a hugely important factor in any piece of software. In our case, ensuring optimum efficiency along with secure, reliable code execution is critical; though our proof-of-concept may be small-scale, the design is intended to work at a scale comprising potentially millions of sensors.</h4>
            <div class="subsection-divide"></div>
            <h3>Software Testing</h3>
            <h4>Visual Testing</h4>
            <p>Our most frequent form of testing, visual testing concepts simplified the learning process for us in areas where we initially had low experience, and also exposed myriad issues throughout development. One such example was the extensive use of visual testing in the development of the server-side software - careful analysis of code operation led to interesting findings and optimisations of concurrency. Indeed, we owe a lot of our robustness to the benefits of visual testing, and have been able to deliver a product of high quality as a consequence of its careful, critical application.</p>
            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/packet_receipt.png">
              <p>The console output of both the system software (receiving packets) and sensor simulator software (10 threads each sending packets every ~10 minutes).</p>
            </div>
            <div class="subsection-divide"></div>
            <h4>Load-testing the server</h4>
            <p>Our server is to be designed to hold up to high levels of traffic, given that it's the backbone of a network potentially comprising hundreds of thousands of sensors. As such, it's important to test the structure we have in place in order to assess how any issues can be rectified in future versions. We've chosen to load-test our server by sending 1000 packets of data simultaneously, from 10 threads running concurrently. Each thread will be updating a single sensor, and will loop 100 times whilst sending an incremented reading with each iteration. In an ideal case, we should be able to see in the data_archive table readings showing 1 - 100 for each tested sensor, with the overall count in the data_archive table for those sensors being 1000, indicating a 100% receipt rate.</p>
            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/loadtest_code.png">
              <p>Our load-testing program creates 10 of these threads, each of which sends 100 distinct readings to the database.</p>
            </div>
            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/loadtest_1.png">
              <p>Three tests were performed each with three repeats - sending 1000 readings with no delay, over the course of a second, and over the course of 10 seconds.</p>
            </div>
            <p>The results were in line with our expectations; UDP as a protocol is by its very nature prone to packet loss. We can see, however, that we have a drop rate of less than 5% when receiving at a rate of 1000 updates per second (86 million per day) - which, one could argue, is within a reasonable tolerance. That said, for data where the update is critical, even a drop rate of 1% could be severely problematic.</p>
            <p>As a consequence of load testing, we have come to the conclusion that support for TCP connections is a must for future versions of the system. UDP is likely to be perfectly practical for regularly updating sensors - e.g. a temperature sensor which updates every 30 seconds or so - because in these situations, losing 5% of packets isn't likely to negatively affect results. Conversely, if a sensor calculates its updates more intelligently (for instance, a parking monitor sending an update only when it's sure it notices a vehicle), delivery of that packet is critical to operation.</p>
            <p>Finally, it's worth noting that the system has been designed with large packets in mind - that is, sending a single data packet containing multiple readings. If users were to have their data sent more economically (for example, ten readings per packet) the maximum data transfer would increase by a factor of the average reading per packet (in this example, x10).</p>
            <div class="subsection-divide"></div>
			<h3> Unit Testing </h3><br>
            <h4>JUnit testing</h4>
            <p>Methods in Java software are very easily tested through JUnit, and we made sure to perform multiple JUnit operations as insurance of reliability. The Java API, example, has a high priority for being bug-free, as it is intended to be distributed publicly for developers. Bugs in our singular system program can be fairly easily tackled without a problem, but to issue updates to a library used in potentially tens of thousands of externally developed applications is a far more damaging process.</p>
            <p>In order to formally test the Java API, the majority of methods were planned ahead. These were the methods whose inclusion was compulsory - for example, retrieving sensors by application label - getIDsWhere(String col, String value) - and then retrieving their readings - getLastReading(int id). JUnit tests were then written in advance using a set of mock readings created in the system database, which included 6 sensors each with 5 readings in the archive. This can be seen below.
            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/testset.png">
              <p>The mock entries into the database tables, created for the purposes of extensive API testing. The full details can be found <a href="res/testset_details.txt">here</a>.</p>
            </div>
            <p>With these in place, the JUnit tests could be written. Below are four such tests, with the set up and tear down methods included. Compare these with the expected values as seen in the test set, above.</p>
            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/junit-methods.png">
              <p>A sample of a few test methods written for testing the Java API.</p>
            </div>
            <p>28 tests in total were run on the Java API, and they highlighted a number of important issues. These included:</p>
            <ul>
              <li>ID lists returned from a query to the Cassandra database were unsorted due to the structure of CQL; this meant that the index of a given reading in the resulting list could not be guaranteed to match the ID at the same index in the IDs list. This was rectified by implementing Java's Arrays.sort method.</li>
              <li>Attempting to filter via timestamp took time to achieve reliably and successfully, and required further work on the API in order to allow full compatability with Java Date objects.</li>
            </ul>

            <p>Once each test and accompanying API method had been written, it took only 3 runs before tests were successful.</p>
            <div class="imgborder">
              <img class="img-responsive img-rounded" src="img/javaapi_success.png">
              <p>The successful run of the test methods.</p>
            </div>
            <div class="subsection-divide"></div>
            <h4>Long-term testing through our use-case</h4>
            <p>As a way to demonstrate our Smart Parking application in action, we produced sensor simulator code to simulate the types of input a parking bay monitor might receive. Over a normal distribution of mean 10 minutes, and a standard deviation of 2 minutes, 10 separate threads would change state and send a reading alternating between above and below 40cm. This therefore averaged one insert a minute, and the software was left running for around 8 days before it was first interrupted for important updates. During this time, visual inspection revealed 100% packet transfer, with no exceptions being thrown at any point.</p>
            <div class="subsection-divide"></div>
			<h4>Frisby.js Testing</h4>
			
			<p>In order to automate testing for our Web API, Frisby.js, a REST API testing framework built on node.js and Jasmine was used. This has enabled 
			rapid testing of individual routes and endpoints during and after the development phase. </p>

			<p>To note, the scope of information which can be retrieved from the REST API is slightly less compared to our other API due to  security and authentication constraints 
			of our system. </p>
			<p>
			The JAVA API enables access to both an SQL database (relevant to the front end of this system, the sensor management portal) 
			and the CQL database where all sensor data is stored and as such tests for both. In contrast, the REST API provides access
			to all sensor data from the CQL database singularly and, in the interests of both security and providing wider public availability is partially the reason 
			user details have been completely separated from the CQL database and placed in an SQL one in order to hide sensitive information from unauthorised read/write via query. 
			</p><p>
			Below, a few of the automated tests written in Frisby are provided. In order to carry this out, mock readings were generated in java simulator code for
			10 different sensor ids to populate the CQL database. This was done to provide an accurate diagnosis on access and correct retrieval of the data_archive where historical data on sensor readings is recorded. 
			</p>
			<div class="imgborder">
              <img class="img-responsive img-rounded" src="img/frisbycodesample.png">
              <p>A sample of a few of the test methods written using frisby.js.</p>
            </div>

			<p>
			<ul>
			10 different tests were run on the REST API. These were for the most part split into two categories to include:
			<li>-> General testing methods - ensuring the correct format of json objects was being retrieved. </li>
			<li>-> Specific testing methods - a subset of the general testing methods, testing specifically for existing json objects and values returned meeting 
			expected json output. </li>
			</ul>
			
			<div class="imgborder">
              <img class="img-responsive img-rounded" src="img/frisbytestspassed.png">
              <p>The command line where tests were executed using Jasmine-node</p>
            </div>
			
			<p>The testing of this API highlighted a few key issues with the database design/ structure and also unique specifics of the CQL language - a subset of SQL.</p>
			
			<p>These include:
			<ul>
			<li>It was not safe to include any user details such as operator_id within the Cassandra database if kept within the same table as meta data on individual sensors.<br>
			  More generally, given the code is open source and the potential to add onto the current REST API code exists, including said data would not be secure at all.</li>
			<li>Complex boolean operations and also the AND operator is not always applicable for querying. As a substitute, the IN keyword has been used instead.</li>
			<li>Due to the way strings are handled as byte arrays, querying with CQL is case sensitive.</li>
			<li>Due to the way the database has been restructured using widerows, it would not allow querying by an attribute that was not a primary key. To solve this issue,
			some restructuring of unique and primary keys occurred along with the inclusion of indexing each row so that this data could be found. </li>
			</ul>			
			</p>			

			
			<div class="subsection-divide"></div>
            <h3>Hardware Testing</h3>
			<h4>Load Testing</h4>
			<p>Some of the tests we did for the hardware were load tests. These served the purpose of testing just how much we can push the system and allow us to set boundaries in terms of what we allow the system to do.</p>
			<h5>ZigBee load test</h5>
			<p>One of the load tests we did was on the ZigBee network. The testing involved sending data at different rates to see how many went through successfully. What we found was that we were able to send data at an incredible rate, far exceeding what we would ever need to send.</p>
			<p>In a test, we send 100 readings in 1 second. Already, this would be far more than we would ever need. At most, 1 zone controller would not have more than 10 sensors anyways. Since we put a delay of around 15 seconds on how often data can be send from each node, the zone controller would at most only ever receive 1 reading from each node a second.</p>
			<h5>Serial ports load test</h5>
			<p>For our hardware, we used serial ports in 2 instances: </p>
      <ul>
			 <li>To send data from our stamp to our Arduino. </li>
			 <li>To send data from our Arduino to our Computer </li>
      </ul>
			<p>In both instances, we were able to send at a baud rate of 115200. This is again far higher than we would ever need, meaning we were able to send data reliably.</p>
			<p>One thing we did find was that when communicating between our computer and the Arduino, the data would sometimes duplicate itself in the first or second reading. To get around this, we simply ignore those initial readings, as this only occurs on startup.</p>
			<h4>Sensor Accuracy</h4>
			<h5>Range</h5>
			<p>The first thing we tested was the range. 
			The recommended range for the Sharp 2Y0A02 Distance Sensor is 20-150cm. What we found was that if the reading went below that, it would start reading false high values:</p>
			<table>
              <tr class="head">
                <th style="width: 50%">Expected reading (cm)</th>
                <th style="width: 50%">Actual reading (cm)</th>
              </tr>
              <tr>
                <td>0</td>
                <td>60</td>
              </tr>
              <tr>
                <td>10</td>
                <td>40</td>
              </tr>
              <tr>
                <td>20</td>
                <td>20</td>
              </tr>
              <tr>
                <td>50</td>
                <td>50</td>
              </tr>
              <tr>
                <td>100</td>
                <td>100</td>
              </tr>
              <tr>
                <td>150</td>
                <td>150</td>
              </tr>
              <tr>
                <td>200</td>
                <td>150</td>
              </tr>
              <tr>
                <td>300</td>
                <td>150</td>
              </tr>
            </table>
			<p>As seen, this could become a problem, as the sensor being covered could be misunderstood for being occupied. The reading is luckily above what we accept as occupied, so if a cars wheel is covering it, it would be read as occupied still. Another thing to note is that the only way it could be covered with our current configuration would be if a wheel of the car was in the center of a parking bay, which would be an illegal way to park either way.</p>
            <h5>Surfaces</h5>
            <p>What we found was that the sensor was surprisingly accurate despite different types of surfaces. Below are examples of tests returning correct values:</p>
            <img class="img-responsive img-rounded" src="img/SensorSurf1.png">
            <img class="img-responsive img-rounded" src="img/SensorSurf2.png">
            <p>As you can see, it pretty much covers all types of surfaces. The only thing that seems to matter when it comes to reflecting off surfaces is the distance. This is because infra-red sends a scatter of beams and as long as one of them returns, it is able to read that.</p>
            <p>We also tested difference materials of surfaces. Surprisingly, it worked on most surfaces. The only one it had trouble with was see through material like glass, but as long as people wont be parking invisible cars, we should be fine.</p>
            <h4>Sensor set up configurations</h4>
            <p>The next thing we tested was the different setups possible with ZigBee. Below are a few of the configurations we tested:</p>
            <img class="img-responsive img-rounded" src="img/SensorConfig.png">
            <p>As you can see, the possibilities are endless. As we have already proven, each node can handle far more data than is ever required here. Even if we had 10 nodes all pointing to one node, it would still easily be handleable.</p>
            <p>The configuration we choose comes down to the kind of parking lot we are dealing with. Its just a matter of changing the code a little for each setup.</p>
            
            <!-- Evaluation -->
            <h2>Evaluation</h2>
            <a class="anchor" id="eval"></a>
            <hr>
            <h3>Successes</h3>
            <h4 style="font-weight: lighter">Throughout this project, we've overcome many challenges and provided a working, feasible proof of concept design for our clients. Performing a requirements review highlights how we have been able to target the specific issues identified in the brief.</h4>
            <div class="subsection-divide"></div>
            <h4>A Plug and Play Architecture</h4>
            <p>We've achieved this through the culmination of multiple design features. First of all, by providing a web service for user sign-up and a remarkably simple sensor registration system. As well as providing a standardised set of metadata, this means that sensors can begin sharing their data in as few as three steps. The second step, of course, is to modify the firmware such that it sends a string in a particular format - with its own ID and the user's identifier. This process of course requires a certain level of technical ability, but there are certainly abstraction layers that can be built, for example in the form of a GUI, to streamline the process. After that, all that's left is to turn it on. In our demonstrations we are able to register as a user, initialise a sensor, set the firmware, and have data being sent all within a few tens of seconds. All of this comes with added benefits of the data being automatically validated, sorted, and standardised for public use.</p>
            <h4>Scalability</h4>
            <p>This has been achieved in multiple ways. </p>
            <p>One of the ways we ensured that our system would be scalable was to switch from a SQL to a noSQL database. An SQL database would have worked just fine for our proof of concept, but if we wanted to ensure that large scale analytics would be possible, we had to use a noSQL database.</p>
            <p>Another way we ensured that our project is scalable is by adding the ability to add sensors of different types. The system itself can store any kinds of data, although the parking app will only use data that is read as a distance and in centimeters. This allows future applications for things like weather apps to use our system to store and access their data.</p>
            <h4>A mesh of data</h4>
            <p>We have multiple databases, which together form our mesh of data. Our SQL database stores all the user data such as location,sensor id, measurement type, etc. This database along with our noSQL database provide a large and descriptive set of data. Our APIs allow for easy access to this data.</p>
            <h4>Full public accessibility</h4>
            <p>We have made this system as easy to use as possible. If the public wishes to add data to our database they simply have to register online and we will do the back end for them. 
            If they wish to use the data in our database they can also use our APIs which have large libraries of functions for accessing the data. 
            The project was designed to be open source and is therefore purposely made as easy to use as possible. 
            This does mean all the data has been made public, however if Orange Labs were to launch this, they have told us that they would release it as an open platform.</p>

            <div class="subsection-divide"></div>

            <h3>Areas for Improvement</h3>
            <h4 style="font-weight: lighter">As with any time-limited project, we'll never feel satisfied that we've explored all of the corners and ironed the creases. As we went along the project, many new and interesting ideas sprang forth. Sadly, we had to place the line somewhere. Here are some areas we feel deserve more attention.</h4>
            <h4>System software administration</h4>
            <p>Currently, the system software has no interface. It's simply a piece of code that is set running and left to loop for eternity. Even as we were building it, we were implementing the tools for developing a command-line interface at the very least. Expanding this, and providing stronger administrator control, is certainly at the top of our priorities list for additions.</p>
            <h4>Usability improvements for the website's Management Portal</h4>
            <p>The management portal has great potential to be a one-stop-shop for all of a user's needs when it comes to interacting with the system. Right now, its functionality is limited to basic sensor monitoring and registration. We'd like to add a filtering or search feature for checking up on specific sensors, the option to activate/deactivate sensors, and controls over system notifications. Users could, for instance, set an automated alert to be emailed to them if a sensor they own hasn't sent an update for the past two hours. Small upgrades like this would really help to transform the attraction of the greater system.</p>
            <h4>Support for TCP connections as well as UDP</h4>
            <p>As seen in our <a href="#test">load testing</a> section above, it became apparent that a more secure connection option would be desired by a number of developers using the system. The protocols required for allowing TCP connections would add an extra layer of complexity to the plug-and-play nature, but if reliability is key, the sacrifices fade into insignificance. With a more secure connection, we can also offer a greater capacity for protection against malicious or spam data contributions.</p>
            <div class="subsection-divide"></div>
            <br>
            <p>That's all from the showcase - we hope it's been informative and engaging. Be sure to look at our <a href="demo.html">demonstration application</a> to see everything in action and explore for yourself!</p>
          </div>
        </div>
      </div>
    </div>

    <div class="container-fluid footer">
      <p style="float: right">This project is proudly presented in partnership with</p>
    </div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script>
    $('#sidebar').affix({
      offset: {
        top: $('#sidebar').offset().top - 92
      }
    });
    </script>
    <script src='https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js' type='text/javascript'></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug
    <script src="./Starter Template for Bootstrap_files/ie10-viewport-bug-workaround.js"></script> -->
</body></html>
